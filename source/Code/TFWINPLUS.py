# -*- coding: utf-8 -*-
"""TFWinplus.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jf_iwEMb57_6WXH3yF6gk9E4JX7RUQOM
"""

class NodeCode:
    def __init__(self, post_order, pre_order, tw):
        self.post_order = post_order
        self.pre_order = pre_order
        self.tw = tw

class TR:
    def __init__(self):
        self.fwi_list = []
        self.ws = 0

class FWI:
    def __init__(self):
        self.n_cs = []
        self.ws = 0

def check_same_equivalence(c_i, c_j):
    # Kiểm tra tính tương đương giữa c_i và c_j
    return False

def tfwinplus_candidate_generation(candidate_k, threshold, ttw):
    candidate_next = []
    for i in range(len(candidate_k) - 1, 0, -1):
        c_i = candidate_k[i]
        for j in range(i - 1, -1, -1):
            c_j = candidate_k[j]
            if check_same_equivalence(c_i, c_j):
                c = FWI()
                if c_i.ws < threshold or c_j.ws < threshold:
                    continue
                sum_tw = 0
                c.n_cs = node_code_combination(c_i.n_cs, c_j.n_cs)
                candidate_next.append(c)
    return candidate_next

def tfwinplus(benchmark_dataset, threshold, ttw):
    # Tạo danh sách các frequent 1-items
    fwis_1 = []

    # Tính toán thông tin về tập dữ liệu
    num_of_trans = len(benchmark_dataset)
    sum_trans_length = sum(len(trans) for trans in benchmark_dataset)

    # Tạo danh sách candidate đầu tiên
    candidate_k = []

    # Thực hiện lặp cho đến khi không còn candidate nào
    while candidate_k:
        # Thực hiện tạo candidate tiếp theo và sắp xếp theo trọng số giảm dần
        candidate = tfwinplus_candidate_generation(candidate_k, threshold, ttw)
        candidate.sort(key=lambda x: x.ws, reverse=True)

        # Lọc các frequent weight itemsets theo ngưỡng trọng số
        fwis_top_rank_k = [c for c in candidate if c.ws >= threshold]

        # Thêm fwis_top_rank_k vào danh sách frequent weight itemsets
        fwis_1.extend(fwis_top_rank_k)

        # Cập nhật candidate_k để tiếp tục vòng lặp
        candidate_k = fwis_top_rank_k
    return fwis_1

# Sử dụng hàm tfwinplus để chạy thuật toán trên tập dữ liệu benchmark
# Sample input data
benchmark_dataset = [
    ['A', 'B', 'C'],
    ['A', 'B'],
    ['A', 'C', 'D'],
    ['B', 'C', 'D'],
    ['B', 'C'],
    ['A', 'C'],
    ['A', 'B'],
    ['C', 'D'],
    ['A', 'B', 'C', 'D']
]
threshold = 0.5
ttw = 0.2

def measure_running_time(benchmark_dataset, threshold, ttw):
    start_time = time.time()

    # Thực hiện giải thuật tfwinplus trên tập dữ liệu benchmark
    fwis = tfwinplus(benchmark_dataset, threshold, ttw)

    end_time = time.time()
    running_time = end_time - start_time

    return running_time, fwis

# Sử dụng hàm measure_running_time để đo thời gian chạy của giải thuật tfwinplus trên tập dữ liệu benchmark
running_time, fwis = measure_running_time(benchmark_dataset, threshold, ttw)

# In kết quả và thời gian chạy
print("Frequent Weighted Itemsets:")
for fwi in fwis:
    print(fwi.n_cs, fwi.ws)

print("Running time:", running_time, "seconds")